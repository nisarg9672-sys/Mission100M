"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FasterRSI = exports.RSI = void 0;
const __1 = require("..");
const Indicator_1 = require("../Indicator");
const WSMA_1 = require("../WSMA/WSMA");
class RSI extends Indicator_1.BigIndicatorSeries {
    constructor(interval, SmoothingIndicator = WSMA_1.WSMA) {
        super();
        this.interval = interval;
        this.maxValue = new __1.Big(100);
        this.avgGain = new SmoothingIndicator(this.interval);
        this.avgLoss = new SmoothingIndicator(this.interval);
    }
    update(price) {
        if (!this.previousPrice) {
            this.previousPrice = price;
            return;
        }
        const currentPrice = new __1.Big(price);
        const previousPrice = new __1.Big(this.previousPrice);
        if (currentPrice.gt(previousPrice)) {
            this.avgLoss.update(new __1.Big(0));
            this.avgGain.update(currentPrice.sub(previousPrice));
        }
        else {
            this.avgLoss.update(previousPrice.sub(currentPrice));
            this.avgGain.update(new __1.Big(0));
        }
        this.previousPrice = price;
        if (this.avgGain.isStable) {
            const avgLoss = this.avgLoss.getResult();
            if (avgLoss.eq(0)) {
                return this.setResult(new __1.Big(100));
            }
            const relativeStrength = this.avgGain.getResult().div(avgLoss);
            return this.setResult(this.maxValue.minus(this.maxValue.div(relativeStrength.add(1))));
        }
    }
}
exports.RSI = RSI;
class FasterRSI extends Indicator_1.NumberIndicatorSeries {
    constructor(interval, SmoothingIndicator = WSMA_1.FasterWSMA) {
        super();
        this.interval = interval;
        this.maxValue = 100;
        this.avgGain = new SmoothingIndicator(this.interval);
        this.avgLoss = new SmoothingIndicator(this.interval);
    }
    update(price) {
        if (!this.previousPrice) {
            this.previousPrice = price;
            return;
        }
        if (price > this.previousPrice) {
            this.avgLoss.update(0);
            this.avgGain.update(price - this.previousPrice);
        }
        else {
            this.avgLoss.update(this.previousPrice - price);
            this.avgGain.update(0);
        }
        this.previousPrice = price;
        if (this.avgGain.isStable) {
            const avgLoss = this.avgLoss.getResult();
            if (avgLoss === 0) {
                return this.setResult(100);
            }
            const relativeStrength = this.avgGain.getResult() / avgLoss;
            return this.setResult(this.maxValue - this.maxValue / (relativeStrength + 1));
        }
    }
}
exports.FasterRSI = FasterRSI;
//# sourceMappingURL=RSI.js.map