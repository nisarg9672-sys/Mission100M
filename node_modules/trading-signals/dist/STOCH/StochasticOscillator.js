"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FasterStochasticOscillator = exports.StochasticOscillator = void 0;
const __1 = require("..");
const SMA_1 = require("../SMA/SMA");
const getMaximum_1 = require("../util/getMaximum");
const getMinimum_1 = require("../util/getMinimum");
const error_1 = require("../error");
class StochasticOscillator {
    constructor(n, m, p) {
        this.n = n;
        this.m = m;
        this.p = p;
        this.candles = [];
        this.periodM = new SMA_1.SMA(m);
        this.periodP = new SMA_1.SMA(p);
    }
    getResult() {
        if (this.result === undefined) {
            throw new error_1.NotEnoughDataError();
        }
        return this.result;
    }
    update(candle) {
        this.candles.push(candle);
        if (this.candles.length > this.n) {
            this.candles.shift();
        }
        if (this.candles.length === this.n) {
            const highest = (0, getMaximum_1.getMaximum)(this.candles.map(candle => candle.high));
            const lowest = (0, getMinimum_1.getMinimum)(this.candles.map(candle => candle.low));
            const divisor = new __1.Big(highest).minus(lowest);
            let fastK = new __1.Big(100).mul(new __1.Big(candle.close).minus(lowest));
            fastK = fastK.div(divisor.eq(0) ? 1 : divisor);
            const stochK = this.periodM.update(fastK);
            const stochD = stochK && this.periodP.update(stochK);
            if (stochK && stochD) {
                return (this.result = {
                    stochD,
                    stochK,
                });
            }
        }
    }
    get isStable() {
        return this.result !== undefined;
    }
}
exports.StochasticOscillator = StochasticOscillator;
class FasterStochasticOscillator {
    constructor(n, m, p) {
        this.n = n;
        this.m = m;
        this.p = p;
        this.candles = [];
        this.periodM = new SMA_1.FasterSMA(m);
        this.periodP = new SMA_1.FasterSMA(p);
    }
    getResult() {
        if (this.result === undefined) {
            throw new error_1.NotEnoughDataError();
        }
        return this.result;
    }
    get isStable() {
        return this.result !== undefined;
    }
    update(candle) {
        this.candles.push(candle);
        if (this.candles.length > this.n) {
            this.candles.shift();
        }
        if (this.candles.length === this.n) {
            const highest = Math.max(...this.candles.map(candle => candle.high));
            const lowest = Math.min(...this.candles.map(candle => candle.low));
            const divisor = highest - lowest;
            let fastK = (candle.close - lowest) * 100;
            fastK = fastK / (divisor === 0 ? 1 : divisor);
            const stochK = this.periodM.update(fastK);
            const stochD = stochK && this.periodP.update(stochK);
            if (stochK !== undefined && stochD !== undefined) {
                return (this.result = {
                    stochD,
                    stochK,
                });
            }
        }
    }
}
exports.FasterStochasticOscillator = FasterStochasticOscillator;
//# sourceMappingURL=StochasticOscillator.js.map